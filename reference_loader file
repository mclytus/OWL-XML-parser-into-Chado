<?php
/**
 * @file
 * @add file from header
 */
require_once ('OWLStanza.inc');
/**
 * Parses an OWL XML file and imports the CV terms into Chado
 *
 * @param $filename The
 *          full path to the OWL XML file.
 *
 * @return No return value.
 *
 * @throws Exception
 */
function tripal_cv_parse_owl($filename) {
  // TODO: this all should occur inside of a transaction.
  // Holds an array of CV and DB records that have already been
  // inserted (reduces number of queires).
  $vocabs = array ();
  // Open the OWL file for parsing.
  $owl = new XMLReader();
  if (!$owl->open($filename)) {
    print "ERROR opening OWL file: '$filename'\n";
    exit();
  }
  // Get the RDF stanza. We pass FALSE as the second parameter to prevent
  // the object from reading the entire file into memory.
  $rdf = new OWLStanza($owl, FALSE);
  // Get the ontology stanza so we can add the database and controlled
  // vocabulary records.
  $ontology = new OWLStanza($owl);
  // //////////////////////////////////////////////////////////////////////////
  // Step 1: Make sure that all dependencies are met
  // //////////////////////////////////////////////////////////////////////////
  // loop through each stanza, one at a time, and handle each one
  // based on the tag name.
  $stanza = new OWLStanza($owl);
  $deps = array ();
  while (!$stanza->isFinished()) {
    // Use the tag name to identify which function should be called.
    switch ($stanza->getTagName()) {
      case 'owl:Class':
        tripal_owl_check_class_depedencies($stanza, $deps);
        break;
    }
    // Get the next stanza in the OWL file.
    $stanza = new OWLStanza($owl);
  }
  print_r($deps);
  if (count($deps) > 0) {
    // We have unmet dependencies. Print those out and return.
    print('Hello, We have missing dependencies. List DB’s first, then terms'."\n");
    exit();
  }
  // Insert the database record into Chado using the owl:Ontology stanza.
  $about = $ontology->getAttribute('rdf:about');
  if (preg_match('/^.*\/(.*)\.owl.*$/', $about, $matches)) {
    $db_name = strtoupper($matches[1]);
  }
  $homepage = $ontology->getChild('foaf:homepage');
  $db = array (
    'url' => $homepage->getValue(),
    'name' => $db_name
  );
  $db = tripal_insert_db($db);
  // Insert the controlled vocabulary record into Chado using the
  // owl:Ontology stanza.
  $title = $ontology->getChild('dc:title');
  $description = $ontology->getChild('dc:description');
  $cv_name = preg_replace("/[^\w]/", "_", strtolower($title->getValue()));
  $cv = tripal_insert_cv($cv_name, $description->getValue());
  // Add this CV and DB to our vocabs array so we can reuse it later.
  $vocabs[$db_name]['cv'] = $cv;
  $vocabs[$db_name]['db'] = $db;
  $vocabs['this'] = $db_name;
  // //////////////////////////////////////////////////////////////////////////
  // Step 2: If we pass the dependency check in step 1 then we can insert
  // the terms.
  // //////////////////////////////////////////////////////////////////////////
  // Reload the ontology to reposition at the beginning for inserting the
  // new terms.
  $owl = new XMLReader();
  $rdf = new OWLStanza($owl, FALSE);
  $ontology = new OWLStanza($owl);
  // loop through each stanza, one at a time, and handle each one
  // based on the tag name.
  $stanza = new OWLStanza($owl);
  while (!$stanza->isFinished()) {
    // Use the tag name to identify which function should be called.
    switch ($stanza->getTagName()) {
      case 'owl:AnnotationProperty':
        // tripal_owl_handle_annotation_property($stanza);
        break;
      case 'rdf:Description':
        // tripal_owl_handle_description($stanza);
        break;
      case 'owl:ObjectProperty':
        // tripal_owl_handle_object_property($stanza);
        break;
      case 'owl:Class':
        tripal_owl_handle_class($stanza, $vocabs);
        break;
      case 'owl:Axiom':
        break;
      case 'owl:Restriction':
        break;
      default:
        throw new Exception("Unhandled stanza: " . $stanza->getTagName());
        exit();
        break;
    }
    // Get the next stanza in the OWL file.
    $stanza = new OWLStanza($owl);
  }
  // Close the XMLReader $owl object.
  $owl->close();
}
/**
 *
 * @param
 *          $stanza
 * @param
 *          $deps
 */
function tripal_owl_check_class_depedencies($stanza, &$deps) {
  // Initialize the database and cv variables.
  $db_name = '';
  $accession = '';
  $db = null;
  // Get the DB name and accession from the about attribute.
  $about = $stanza->getAttribute('rdf:about');
  // print_r($about);
  if (preg_match('/.*\/(.+)_(.+)/', $about, $matches)) {
    $db_name = strtoupper($matches[1]);
    $accession = $matches[2];
  }
  else {
    throw new Exception("owl:Class stanza is missing the
     'rdf:about' attribute. " . "This is necessary to determine the term's accession: \n\n" . $stanza->getXML());
  }
  // Check if the db_name does not exists in the chado.db table.
  $db = chado_select_record('db', array('db_id'), array('name' => $db_name));
  // Insert a DB record if it doesn't already exist.
  if ($db == FALSE) {
  }
    else {
      "An empty array if no records were matched". $deps['db'][$db_name] = TRUE;
    //$deps['dbxref'][$db_name . ':' . $accession] = TRUE;
  }
  // If the db_name does exist then check if the accession exists in the
  // chado.dbxref table.
  // if (!$dbxref) {
  // $dbxref = chado_select_record ('db_id', array(
  // 'db_id' => $db->db_id,
  // 'accession' => $accession,
  // $deps['dbxref'][] = $db_name . ':' . $accession,
  // ));
  // }
}
/**
 *
 * @param
 *          $owl
 */
function tripal_owl_handle_object_property($stanza) {
}
/**
 *
 * @param
 *          $owl
 */
function tripal_owl_handle_annotation_property($stanza) {
}
/**
 *
 * @param
 *          $owl
 */
function tripal_owl_handle_description($stanza) {
}
/**
 *
 * @param
 *          $owl
 */
function tripal_owl_handle_class($stanza, $vocabs) {
  // Initialize the database and cv variables.
  $db_name = '';
  $accession = '';
  $db = null;
  $cv = null;
  // Get the DB name and accession from the about attribute.
  $about = $stanza->getAttribute('rdf:about');
  if (preg_match('/.*\/(.+)_(.+)/', $about, $matches)) {
    $db_name = strtoupper($matches[1]);
    $accession = $matches[2];
  }
  else {
    throw new Exception("owl:Class stanza is missing the 'rdf:about' attribute. " . "This is necessary to determine the term's accession: \n\n" . $stanza->getXML());
  }
  // Insert a DB record if it doesn't already exist.
  if (array_key_exists($db_name, $vocabs)) {
    $db = $vocabs[$db_name]['db'];
    $cv = $vocabs[$db_name]['cv'];
  }
  else {
    // Unfortunately, all we have is the name. The OWL format
    // doesn't provides us the URL, description, etc.
    $values = array (
      'name' => $db_name
    );
    $db = tripal_insert_db($values);
    // Check to see if this database has records and if so, what CV it is using.
    // Because the OWL Class doensn't specify a name that Chado wants for the
    // cv table, we have to discover it or add it. If we find a single record
    // that has a cvterm (hence associated with a CV) then we'll reuse the same
    // CV. Otherwise, we must add a new CV record and we'll use the $db_name
    // as the name.
    $sql = "
  SELECT CV.*
  FROM {cvterm} CVT
  INNER JOIN {dbxref} DBX ON DBX.dbxref_id = CVT.dbxref_id
  INNER JOIN {db} DB ON DB.db_id = DBX.db_id
  INNER JOIN {cv} CV ON CVT.cv_id = CV.cv_id
  WHERE DB.db_id = :db_id
  LIMIT 1 OFFSET 0
  ";
    $results = chado_query($sql, array (
      ':db_id' => $db->db_id
    ));
    $cv = $results->fetchObject();
    // If there are no terms using this database then we need to add the
    // vocabulary.
    if (!$cv) {
      $cv = tripal_insert_cv($db->name, '');
    }
    // Add our new DB and CV to the vocab array.
    $vocabs[$db_name]['cv'] = $cv;
    $vocabs[$db_name]['db'] = $db;
    if ($db_name == $vocabs['this']) {
      // Insert a dbxref record.
      $values = array (
        'db_id' => $db->db_id,
        'accession' => $accession
      );
      $dbxref = tripal_insert_dbxref($values);
    }
    // Insert a new cvterm record.
    $cvterm_name = '';
    $definition = '';
    $term = array (
      'id' => $db->name . ':' . $dbxref->accession,
      'name' => $cvterm_name,
      'cv_name' => $cv->name,
      'definition' => $definition
    );
    $option = array ();
    if ($vocabs['this'] != $db->name) {
      $option['update_existing'] = FALSE;
    }
    $cvterm = tripal_insert_cvterm($term, $option);
  }
}
Status API Training Shop Blog About
© 2016 GitHub, Inc. Terms Privacy Security Contact Help
